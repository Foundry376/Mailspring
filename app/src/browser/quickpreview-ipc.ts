import { IpcMain, IpcMainInvokeEvent } from 'electron/main';
import crypto from 'crypto';

const fs = require('fs');
const path = require('path');

// Map of opaque tokens to preview paths for secure file writes
const previewTokens = new Map<string, string>();

/**
 * Generate a secure opaque token for a preview path.
 * This prevents the renderer from specifying arbitrary file paths.
 */
export function generatePreviewToken(previewPath: string): string {
  const token = crypto.randomBytes(32).toString('hex');
  previewTokens.set(token, previewPath);
  return token;
}

/**
 * Clean up a preview token without using it.
 * Called when preview times out or window closes.
 */
export function cleanupPreviewToken(token: string): void {
  previewTokens.delete(token);
}

/**
 * Validate that the IPC sender is a legitimate quickpreview renderer.
 */
const validateSender = (event: IpcMainInvokeEvent) => {
  const url = event.sender.getURL();
  const pathname = new URL(url).pathname;
  // Only allow requests from the quickpreview renderer.html
  if (!pathname.endsWith('/src/quickpreview/renderer.html')) {
    throw new Error('Invalid IPC sender: request not from quickpreview renderer');
  }
};

/**
 * Validate that a file path is within the allowed files directory.
 * Uses path.resolve() to prevent directory traversal attacks.
 */
const checkPathIsWithinFiles = (filePath: string): string => {
  const baseDir = path.join(global.application.configDirPath, 'files');
  const resolvedBase = path.resolve(baseDir);
  const resolvedTarget = path.resolve(filePath);

  // Ensure resolved path is within the allowed directory
  // Append path.sep to prevent prefix-matching attacks (e.g., /files-evil/)
  if (!resolvedTarget.startsWith(resolvedBase + path.sep)) {
    throw new Error(`Quick preview cannot access this directory: ${filePath}`);
  }

  return resolvedTarget;
};

const getFilePath = (url: string) => {
  const { filePath } = JSON.parse(decodeURIComponent(new URL(url).search.slice(1)));
  return checkPathIsWithinFiles(filePath);
};

const previewFileAsString = (event: IpcMainInvokeEvent, { truncate } = { truncate: false }) => {
  validateSender(event);
  const filepath = getFilePath(event.sender.getURL());
  let raw = fs.readFileSync(filepath).toString();
  if (truncate) raw = raw.substr(0, 1000);
  return raw;
};

const previewFileAsBuffer = (event: IpcMainInvokeEvent) => {
  validateSender(event);
  const filepath = getFilePath(event.sender.getURL());
  return fs.readFileSync(filepath);
};

const previewFileAsMammothHTML = async (event: IpcMainInvokeEvent) => {
  validateSender(event);
  const filepath = getFilePath(event.sender.getURL());
  const mammoth = require('mammoth');
  const result = await mammoth.convertToHtml({ path: filepath });
  return result.value;
};

const previewFileAsSnarkdownHTML = async (event: IpcMainInvokeEvent) => {
  validateSender(event);
  const filepath = getFilePath(event.sender.getURL());
  const md = fs.readFileSync(filepath).toString();
  return require('snarkdown')(md);
};

/**
 * Write preview data using an opaque token instead of a direct path.
 * The token must have been generated by generatePreviewToken().
 */
const finishWithData = (event: IpcMainInvokeEvent, previewToken: string, arrayBuffer: ArrayBuffer) => {
  validateSender(event);
  const previewPath = previewTokens.get(previewToken);
  if (!previewPath) {
    throw new Error('Invalid or expired preview token');
  }
  // Token is single-use
  previewTokens.delete(previewToken);
  // Still validate the path as defense-in-depth
  const resolvedPath = checkPathIsWithinFiles(previewPath);
  fs.writeFileSync(resolvedPath, Buffer.from(arrayBuffer));
};

/**
 * Capture window screenshot using an opaque token instead of a direct path.
 * The token must have been generated by generatePreviewToken().
 */
const finishCapture = async (event: IpcMainInvokeEvent, previewToken: string) => {
  validateSender(event);
  const previewPath = previewTokens.get(previewToken);
  if (!previewPath) {
    throw new Error('Invalid or expired preview token');
  }
  // Token is single-use
  previewTokens.delete(previewToken);
  // Still validate the path as defense-in-depth
  const resolvedPath = checkPathIsWithinFiles(previewPath);
  const img = await event.sender.capturePage();
  fs.writeFileSync(resolvedPath, img.toPNG());
};

export function registerQuickpreviewIPCHandlers(ipcMain: IpcMain) {
  ipcMain.handle('quickpreview:previewFileAsString', previewFileAsString);
  ipcMain.handle('quickpreview:previewFileAsBuffer', previewFileAsBuffer);
  ipcMain.handle('quickpreview:previewFileAsMammothHTML', previewFileAsMammothHTML);
  ipcMain.handle('quickpreview:previewFileAsSnarkdownHTML', previewFileAsSnarkdownHTML);
  ipcMain.handle('quickpreview:finishWithData', finishWithData);
  ipcMain.handle('quickpreview:finishCapture', finishCapture);
  ipcMain.handle('quickpreview:generateToken', (_, previewPath: string) => {
    return generatePreviewToken(previewPath);
  });
  ipcMain.handle('quickpreview:cleanupToken', (_, token: string) => {
    cleanupPreviewToken(token);
  });
}
